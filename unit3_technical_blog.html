<DOCTYPE!html>
<html>
<head>
	<title>Unit 3 Technical</title>
	<link rel="stylesheet" type="text/css" href="stylesheets/blog.css">
	<link href='http://fonts.googleapis.com/css?family=Andika' rel='stylesheet' type='text/css'>
  <link rel="icon" type="image/png" href="https://cdn0.iconfinder.com/data/icons/smile-emoticons/78/smyle_emoticons-07-512.png">
</head>

<body>
  <nav>
    <ul>
      <li><a href="http://tjhernandez34.github.io/index.html">Home</a></li>
        <li><a href="http://tjhernandez34.github.io/about.html">About</a></li>
        <li><a href="">Blog Posts</a>
          <ul>
              <li><a href="">Technical Blog</a>
                <ul>
                  <li><a href="http://tjhernandez34.github.io/unit1_technical_blog.html">Unit One</a></li>
                  <li><a href="http://tjhernandez34.github.io/unit2_technical_blog.html">Unit Two</a></li>
                  <li><a href="http://tjhernandez34.github.io/unit3_technical_blog.html">Unit Three</a></li>
                </ul>
              </li>
              <li ><a href="">Cultural Blog</a>
                <ul>
                  <li><a href="http://tjhernandez34.github.io/unit1_cultural_blog.html">Unit One</a></li>
                  <li><a href="http://tjhernandez34.github.io/unit2_cultural_blog.html">Unit Two</a></li>
                  <li><a href="http://tjhernandez34.github.io/unit3_cultural_blog.html">Unit Three</a></li>
                </ul>
              </li>
          </ul>
        </li>
        <li><a href="http://tjhernandez34.github.io/photos.html">Photos</a></li>
        <li><a href="http://tjhernandez34.github.io/contact.html">Contact Info</a></li>
    </ul>
    <div id="subheader"><p></p></div>
  </nav>
    <<div class="content" id="leadsub"><p></p></div>
<div class="content" id="top">
  <h3>May 2, 2014</h3>
<h1>Test-Driven Development (TDD)</h1>
<h3>What is it?</h3>
<p>Test-driven development is a software development style that uses a short code development cycle. First, the developer writes test code for a problem with an expected outcome, and then creates the code to satisfy that test.</p>
<h3>How it is done?</h3>
Step One: Write a test
Step Two: Run the test to make sure it fails.
-This is an important piece for a couple reasons. First, you want to make sure the test you have written actually runs, and second you want to make sure the test doesn’t pass without the code you will be writing to make it pass. Essentially, this second scenario would render your test useless at evaluating your code because it passes without your code even existing yet.
Step Three: Write your code
Step Four: Run your test
-Did your code pass? If yes, continue. If no, refactor and repeat steps three and four until it passes.
Step Five: Refactor your code to make it more concise or readable.
Step Six: Repeat the process
<p> Here is a nice graphic of the process from wikipedia</p>
<img id="tdd" src="http://upload.wikimedia.org/wikipedia/en/9/9c/Test-driven_development.PNG"/>
<h3>Pros</h3>
<p>This development model is good for a number of reasons. One of these is that this style incorporates the concepts of tests right from the outset of the code. This can be beneficial because it leads to a more straightforward and elegant code that satisfies the functionality requirements of the program in a step by step process. This is an advantage over a code that doesn’t take testing into account from the beginning because the developer isn’t having to go back and write tests that will show if the code is working and the prewritten tests keep the code focused and concise. Also, writing the code in smaller segments leads for easier debugging because it is easier to see where the test failure arises.</p>
<h3>Cons</h3>
<p>TTD doesn’t work well in situations where full functional tests are needed. These are situations where you are testing user interface interaction with the database and similar types of situations. Also, the quality of the processes are only as good as the developer writing them. For example, if the developer overlooks a part of the code, and writes his tests overlooking this part of the code that is lacking, then the tests will still pass, but the code won’t be what it needed to be. TTD creates lots of passing tests, which may deter programmers from performing other types of testing on their code. Finally, if big changes are made to a project, all of the existing code is under threat of being broken because they were written for and passed under a previous structure and layout of the program.</p>
<h3>Best Practices</h3>
<p>Here is a list of what I think are the 5 most important best practices to incorporate when doing TDD:</p>
<ol>
  <li>Don’t create tests that are dependent on the outcomes of other tests.
      <ul>
        <li>This is a bad practice because if one part of the code is changed, it can make a test fail, resulting in a cascade of failures, which makes it harder to pinpoint where the code is broken.</li>
      </ul>
  </li>
  <li>Make sure tests fail immediately after writing them.
      <ul>
        <li>Don’t go into writing code for a test you want to have pass, when it already passes without the code you wrote for it. It doesn’t show whether or not the code you have written works.</li>
      </ul>
  </li>
  <li>Rerun tests after every change you make to the code.
      <ul>
        <li>This makes it much easier to pinpoint the spot at which your code breaks when you are refactoring.</li>
      </ul>
  </li>
  <li>All tests should pass before writing the next test.
      <ul>
        <li>Keep it simple, using good step by step code writing reduces the risks of broken code later.</li>
      </ul>
  </li>
  <li>Your tests should be just as readable as your code.
      <ul>
        <li>You don’t want someone who is reviewing your code to be confused about what the tests are looking for, just like you wouldn't want them to be confused by what it is doing.</li>
      </ul>
  </li>
</ol>    
</div>
<div class="content">
  <h3>April 26, 2014</h3>
<h1>SQL Issues: SQL Injection</h1>
<p>SQL Injection is a way of exploiting web applications using SQL databases by inserting new SQL command lines into the existing SQL command lines through the web application, where the user can enter fields of text to be uploaded to the SQL database. The inserted lines are then run through the normal sequence of the current SQL. This enables the attacker to run whichever command line SQL queries that they want through the web application of the SQL database.</p>
<p>This creates a huge problem because SQL commands are considered safe by most security models of websites. This allows an attacker to change or manipulate the queries being run by the program, which can alter or even destroy the SQL data that is contained within the table being accessed. In worst case scenarios, this technique will give attackers access to confidential or sensitive information; social security numbers, etc.
A few ways that you can prevent SQL Injection from occurring are as follows:</p>
<p>-A programmer can set very specific parameters for the data that is being input, ie length, type, syntax.</p>
<p>-Provide users of the SQL database the lowest level of security clearance within the system, and also only allow a specific user to access the specific application that they are using rather than access to the entire system.</p>
<p>-Following this, disable all stored procedures when they are not in use.</p>
<p>Let’s take a look at the differences at two main types of Query Languages, SQL and NoSQL.</p>
<img src="https://farm3.staticflickr.com/2903/14017653181_4c88bf6c3f_z.jpg"/>
<p>I feel like I would prefer to be working with SQL databases because their structure seems more rigid, and therefore I would imagine it is easier to maintain and use. The NoSQL databases seem a little bit more abstract and versatile, but with these two attributes comes less defined rules, which to me means less clear ways to fix problems that arise with the structure you have created. Another reason I am more interested in using SQL Databases is because I just see a lot more practicality in them. Most of the data we use and view is in tables, and they have the same attributes for each individual occurrence. Therefore, I would prefer to work with something I can see myself not only understanding better, but using frequently.</p>
<h3>Query Optimization</h3>
<p>When addressing the problem of query optimization for large data sets, there are a few tips and tricks that one can use to relieve pressures put on the system. Each table item should have a unique ID specific to that line, when you run a query on a particular group, you can save that output which corresponds to the query for that data set, then when your data increases you can run a query on the additional data and add it to the previous query. This prevents the query from retracing through a dataset that it has already created an answer for. This enables the program to finish faster and take up less computational resources on the server. Another way to avoid stressing the system is to use constants in your queries, this enables the computer to bypass the need to scan every individual item searching for matching text, values, etc.</p>
</div>
</div>
</body>